<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Marlin: marlin::concurrency::ThreadPool&lt; IN, OUT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marlin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>marlin</b></li><li class="navelem"><b>concurrency</b></li><li class="navelem"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmarlin_1_1concurrency_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">marlin::concurrency::ThreadPool&lt; IN, OUT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html" title="ThreadPool class The template parameter T is the type of data to enqueue and process in worker thread...">ThreadPool</a> class The template parameter T is the type of data to enqueue and process in worker threads.  
 <a href="classmarlin_1_1concurrency_1_1ThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa812123afc377d93ad4d91cd6b3daed2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2">PushPolicy</a> { <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2abd0ca6be53b0f3d2886fd53fcb52574e">PushPolicy::Blocking</a>, 
<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2afa9df3c61a331de501ef79fdfe81ad4a">PushPolicy::ThrowIfFull</a>
 }<tr class="memdesc:aa812123afc377d93ad4d91cd6b3daed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">PushPolicy enumerator.  <a href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa812123afc377d93ad4d91cd6b3daed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b47339b03f6dc64a45bddc7b213ab"><td class="memItemLeft" align="right" valign="top"><a id="a728b47339b03f6dc64a45bddc7b213ab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QueueType</b> = <a class="el" href="classmarlin_1_1concurrency_1_1Queue.html">Queue</a>&lt; <a class="el" href="classmarlin_1_1concurrency_1_1QueueElement.html">QueueElement</a>&lt; IN, OUT &gt; &gt;</td></tr>
<tr class="separator:a728b47339b03f6dc64a45bddc7b213ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f1a68f35e294d8da5d6af55904649"><td class="memItemLeft" align="right" valign="top"><a id="a690f1a68f35e294d8da5d6af55904649"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PoolType</b> = std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmarlin_1_1concurrency_1_1Worker.html">Worker</a>&lt; IN, OUT &gt; &gt;&gt;</td></tr>
<tr class="separator:a690f1a68f35e294d8da5d6af55904649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5233168cd4afe40c3c98ffcd54ebd560"><td class="memItemLeft" align="right" valign="top"><a id="a5233168cd4afe40c3c98ffcd54ebd560"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Promise</b> = std::shared_ptr&lt; std::promise&lt; OUT &gt; &gt;</td></tr>
<tr class="separator:a5233168cd4afe40c3c98ffcd54ebd560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016f81f23b6dfc5d9312e8d2ecdaf520"><td class="memItemLeft" align="right" valign="top"><a id="a016f81f23b6dfc5d9312e8d2ecdaf520"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> = std::future&lt; OUT &gt;</td></tr>
<tr class="separator:a016f81f23b6dfc5d9312e8d2ecdaf520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6056a836a7bff61e8438aa72d01edfc"><td class="memItemLeft" align="right" valign="top"><a id="ac6056a836a7bff61e8438aa72d01edfc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PushResult</b> = std::pair&lt; Promise, Future &gt;</td></tr>
<tr class="separator:ac6056a836a7bff61e8438aa72d01edfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebc1ddd5d4d9767a3885b667a51261ca"><td class="memItemLeft" align="right" valign="top"><a id="aebc1ddd5d4d9767a3885b667a51261ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPool</b> (const <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="separator:aebc1ddd5d4d9767a3885b667a51261ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f331c64fb54362f91ecf9e10cd5412"><td class="memItemLeft" align="right" valign="top"><a id="a42f331c64fb54362f91ecf9e10cd5412"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPool</b> (<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a42f331c64fb54362f91ecf9e10cd5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46f66c0c8442e02e0dad022b7c956c4"><td class="memItemLeft" align="right" valign="top"><a id="af46f66c0c8442e02e0dad022b7c956c4"></a>
<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="separator:af46f66c0c8442e02e0dad022b7c956c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6822bc8aee4922871ad77628db72961"><td class="memItemLeft" align="right" valign="top"><a id="ab6822bc8aee4922871ad77628db72961"></a>
<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab6822bc8aee4922871ad77628db72961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ec499f35e1d37c8c32e03442a59ebe"><td class="memItemLeft" align="right" valign="top"><a id="ae4ec499f35e1d37c8c32e03442a59ebe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#ae4ec499f35e1d37c8c32e03442a59ebe">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:ae4ec499f35e1d37c8c32e03442a59ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae4ec499f35e1d37c8c32e03442a59ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7bc6b1caed163cb2f54aa35c7246da"><td class="memTemplParams" colspan="2">template&lt;typename WORKER , typename ... Args&gt; </td></tr>
<tr class="memitem:aaf7bc6b1caed163cb2f54aa35c7246da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aaf7bc6b1caed163cb2f54aa35c7246da">addWorker</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aaf7bc6b1caed163cb2f54aa35c7246da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new worker thread.  <a href="#aaf7bc6b1caed163cb2f54aa35c7246da">More...</a><br /></td></tr>
<tr class="separator:aaf7bc6b1caed163cb2f54aa35c7246da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cddd87b3820d13b99e4f5fae79cc006"><td class="memItemLeft" align="right" valign="top"><a id="a1cddd87b3820d13b99e4f5fae79cc006"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a1cddd87b3820d13b99e4f5fae79cc006">start</a> ()</td></tr>
<tr class="memdesc:a1cddd87b3820d13b99e4f5fae79cc006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the worker threads. <br /></td></tr>
<tr class="separator:a1cddd87b3820d13b99e4f5fae79cc006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad45418d2b691dc4703b880e6d797b4d"><td class="memItemLeft" align="right" valign="top"><a id="aad45418d2b691dc4703b880e6d797b4d"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aad45418d2b691dc4703b880e6d797b4d">size</a> () const</td></tr>
<tr class="memdesc:aad45418d2b691dc4703b880e6d797b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread pool size. <br /></td></tr>
<tr class="separator:aad45418d2b691dc4703b880e6d797b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5a9bec06e7984168530bdfb4cf0242"><td class="memItemLeft" align="right" valign="top"><a id="a0a5a9bec06e7984168530bdfb4cf0242"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a0a5a9bec06e7984168530bdfb4cf0242">nWaiting</a> () const</td></tr>
<tr class="memdesc:a0a5a9bec06e7984168530bdfb4cf0242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of waiting threads. <br /></td></tr>
<tr class="separator:a0a5a9bec06e7984168530bdfb4cf0242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be8a902065c31077ef345cd03036d01"><td class="memItemLeft" align="right" valign="top"><a id="a3be8a902065c31077ef345cd03036d01"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a3be8a902065c31077ef345cd03036d01">nRunning</a> () const</td></tr>
<tr class="memdesc:a3be8a902065c31077ef345cd03036d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads currently handling a task. <br /></td></tr>
<tr class="separator:a3be8a902065c31077ef345cd03036d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a"><td class="memItemLeft" align="right" valign="top"><a id="a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a">freeSlots</a> () const</td></tr>
<tr class="memdesc:a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of free slots in the task queue. <br /></td></tr>
<tr class="separator:a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca960e716e99fd64eca3a107a43b4b1"><td class="memItemLeft" align="right" valign="top"><a id="a2ca960e716e99fd64eca3a107a43b4b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a2ca960e716e99fd64eca3a107a43b4b1">isQueueEmpty</a> () const</td></tr>
<tr class="memdesc:a2ca960e716e99fd64eca3a107a43b4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the queue is empty. <br /></td></tr>
<tr class="separator:a2ca960e716e99fd64eca3a107a43b4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cc65198d64d5f32ba889b1e0c1754b"><td class="memItemLeft" align="right" valign="top"><a id="a68cc65198d64d5f32ba889b1e0c1754b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a68cc65198d64d5f32ba889b1e0c1754b">clearQueue</a> ()</td></tr>
<tr class="memdesc:a68cc65198d64d5f32ba889b1e0c1754b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue. <br /></td></tr>
<tr class="separator:a68cc65198d64d5f32ba889b1e0c1754b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665133f4e606e22dd13559601dfccbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#ad665133f4e606e22dd13559601dfccbb">setMaxQueueSize</a> (std::size_t maxQueueSize)</td></tr>
<tr class="memdesc:ad665133f4e606e22dd13559601dfccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum queue size.  <a href="#ad665133f4e606e22dd13559601dfccbb">More...</a><br /></td></tr>
<tr class="separator:ad665133f4e606e22dd13559601dfccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b937d90dfd341103aa33eab98b136e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#af1b937d90dfd341103aa33eab98b136e">setAcceptPush</a> (bool accept)</td></tr>
<tr class="memdesc:af1b937d90dfd341103aa33eab98b136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the thread pool accept data push.  <a href="#af1b937d90dfd341103aa33eab98b136e">More...</a><br /></td></tr>
<tr class="separator:af1b937d90dfd341103aa33eab98b136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300c5d5df797a2a04d8c674c6dc3f348"><td class="memItemLeft" align="right" valign="top"><a id="a300c5d5df797a2a04d8c674c6dc3f348"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a300c5d5df797a2a04d8c674c6dc3f348">acceptPush</a> () const</td></tr>
<tr class="memdesc:a300c5d5df797a2a04d8c674c6dc3f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the thread pool accepts data push. <br /></td></tr>
<tr class="separator:a300c5d5df797a2a04d8c674c6dc3f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5503a48ee34adcf03a7a4e53a7d75a0"><td class="memItemLeft" align="right" valign="top"><a id="ae5503a48ee34adcf03a7a4e53a7d75a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#ae5503a48ee34adcf03a7a4e53a7d75a0">active</a> () const</td></tr>
<tr class="memdesc:ae5503a48ee34adcf03a7a4e53a7d75a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the thread pool is active, meaning that the queue is not empty or at least one worker is active. <br /></td></tr>
<tr class="separator:ae5503a48ee34adcf03a7a4e53a7d75a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaed70df966cb82296cf7ba794e6705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#acbaed70df966cb82296cf7ba794e6705">stop</a> (bool clear=true)</td></tr>
<tr class="memdesc:acbaed70df966cb82296cf7ba794e6705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread pool.  <a href="#acbaed70df966cb82296cf7ba794e6705">More...</a><br /></td></tr>
<tr class="separator:acbaed70df966cb82296cf7ba794e6705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d1d6077b516d0aa5a2244c378e7979"><td class="memTemplParams" colspan="2">template&lt;class  = typename std::enable_if&lt;not std::is_same&lt;IN,void&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a60d1d6077b516d0aa5a2244c378e7979"><td class="memTemplItemLeft" align="right" valign="top">PushResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#a60d1d6077b516d0aa5a2244c378e7979">push</a> (<a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2">PushPolicy</a> policy, IN &amp;&amp;input)</td></tr>
<tr class="memdesc:a60d1d6077b516d0aa5a2244c378e7979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new task in the task queue.  <a href="#a60d1d6077b516d0aa5a2244c378e7979">More...</a><br /></td></tr>
<tr class="separator:a60d1d6077b516d0aa5a2244c378e7979"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a491b906d2052cbe1c394c75e0e2d72a5"><td class="memItemLeft" align="right" valign="top"><a id="a491b906d2052cbe1c394c75e0e2d72a5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Worker&lt; IN, OUT &gt;</b></td></tr>
<tr class="separator:a491b906d2052cbe1c394c75e0e2d72a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename IN, typename OUT&gt;<br />
class marlin::concurrency::ThreadPool&lt; IN, OUT &gt;</h3>

<p><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html" title="ThreadPool class The template parameter T is the type of data to enqueue and process in worker thread...">ThreadPool</a> class The template parameter T is the type of data to enqueue and process in worker threads. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa812123afc377d93ad4d91cd6b3daed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa812123afc377d93ad4d91cd6b3daed2">&#9670;&nbsp;</a></span>PushPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN, typename OUT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2">marlin::concurrency::ThreadPool::PushPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PushPolicy enumerator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa812123afc377d93ad4d91cd6b3daed2abd0ca6be53b0f3d2886fd53fcb52574e"></a>Blocking&#160;</td><td class="fielddoc"><p>Block until a slot is free in the queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa812123afc377d93ad4d91cd6b3daed2afa9df3c61a331de501ef79fdfe81ad4a"></a>ThrowIfFull&#160;</td><td class="fielddoc"><p>Throw an exception if the queue is full. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf7bc6b1caed163cb2f54aa35c7246da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7bc6b1caed163cb2f54aa35c7246da">&#9670;&nbsp;</a></span>addWorker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN , typename OUT &gt; </div>
<div class="memtemplate">
template&lt;typename WORKER , typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">marlin::concurrency::ThreadPool</a>&lt; IN, OUT &gt;::addWorker </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to pass to worker constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60d1d6077b516d0aa5a2244c378e7979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d1d6077b516d0aa5a2244c378e7979">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN, typename OUT &gt; </div>
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">ThreadPool</a>&lt; IN, OUT &gt;::PushResult <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">marlin::concurrency::ThreadPool</a>&lt; IN, OUT &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#aa812123afc377d93ad4d91cd6b3daed2">PushPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a new task in the task queue. </p>
<p>See PushPolicy for runtime behavior of enqueuing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>the push policy </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b937d90dfd341103aa33eab98b136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b937d90dfd341103aa33eab98b136e">&#9670;&nbsp;</a></span>setAcceptPush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN , typename OUT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">marlin::concurrency::ThreadPool</a>&lt; IN, OUT &gt;::setAcceptPush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accept</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the thread pool accept data push. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accept</td><td>whether to accept data push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad665133f4e606e22dd13559601dfccbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad665133f4e606e22dd13559601dfccbb">&#9670;&nbsp;</a></span>setMaxQueueSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN , typename OUT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">marlin::concurrency::ThreadPool</a>&lt; IN, OUT &gt;::setMaxQueueSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxQueueSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum queue size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxQueueSize</td><td>the maximum queue size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbaed70df966cb82296cf7ba794e6705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaed70df966cb82296cf7ba794e6705">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN , typename OUT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html">marlin::concurrency::ThreadPool</a>&lt; IN, OUT &gt;::stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the thread pool. </p>
<p>If the flag clear is set to true, the task queue is cleared. The threads are joined and the pool is clear. As no threads remains in the pool, the pool is not reusable. Thus this method must be called for performing a proper program termination before exiting</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear</td><td>whether the task queue should be cleared </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classmarlin_1_1concurrency_1_1ThreadPool.html#ae4ec499f35e1d37c8c32e03442a59ebe">marlin::concurrency::ThreadPool&lt; InputType, OutputType &gt;::~ThreadPool()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
