\section{marlin\+:\+:concurrency\+:\+:Thread\+Pool$<$ IN, O\+UT $>$ Class Template Reference}
\label{classmarlin_1_1concurrency_1_1ThreadPool}\index{marlin\+::concurrency\+::\+Thread\+Pool$<$ I\+N, O\+U\+T $>$@{marlin\+::concurrency\+::\+Thread\+Pool$<$ I\+N, O\+U\+T $>$}}


\doxyref{Thread\+Pool}{p.}{classmarlin_1_1concurrency_1_1ThreadPool} class The template parameter T is the type of data to enqueue and process in worker threads.  




{\ttfamily \#include $<$Thread\+Pool.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Push\+Policy} \{ \textbf{ Push\+Policy\+::\+Blocking}, 
\textbf{ Push\+Policy\+::\+Throw\+If\+Full}
 \}\begin{DoxyCompactList}\small\item\em Push\+Policy enumerator. \end{DoxyCompactList}
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a728b47339b03f6dc64a45bddc7b213ab}} 
using {\bfseries Queue\+Type} = \textbf{ Queue}$<$ \textbf{ Queue\+Element}$<$ IN, O\+UT $>$ $>$
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a690f1a68f35e294d8da5d6af55904649}} 
using {\bfseries Pool\+Type} = std\+::vector$<$ std\+::shared\+\_\+ptr$<$ \textbf{ Worker}$<$ IN, O\+UT $>$ $>$$>$
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a5233168cd4afe40c3c98ffcd54ebd560}} 
using {\bfseries Promise} = std\+::shared\+\_\+ptr$<$ std\+::promise$<$ O\+UT $>$ $>$
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a016f81f23b6dfc5d9312e8d2ecdaf520}} 
using {\bfseries Future} = std\+::future$<$ O\+UT $>$
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_ac6056a836a7bff61e8438aa72d01edfc}} 
using {\bfseries Push\+Result} = std\+::pair$<$ Promise, Future $>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aebc1ddd5d4d9767a3885b667a51261ca}} 
{\bfseries Thread\+Pool} (const \textbf{ Thread\+Pool} \&)=delete
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a42f331c64fb54362f91ecf9e10cd5412}} 
{\bfseries Thread\+Pool} (\textbf{ Thread\+Pool} \&\&)=delete
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_af46f66c0c8442e02e0dad022b7c956c4}} 
\textbf{ Thread\+Pool} \& {\bfseries operator=} (const \textbf{ Thread\+Pool} \&)=delete
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_ab6822bc8aee4922871ad77628db72961}} 
\textbf{ Thread\+Pool} \& {\bfseries operator=} (\textbf{ Thread\+Pool} \&\&)=delete
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_ae4ec499f35e1d37c8c32e03442a59ebe}} 
\textbf{ $\sim$\+Thread\+Pool} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename W\+O\+R\+K\+ER , typename ... Args$>$ }\\void \textbf{ add\+Worker} (Args \&\&...args)
\begin{DoxyCompactList}\small\item\em Add a new worker thread. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a1cddd87b3820d13b99e4f5fae79cc006}} 
void \textbf{ start} ()
\begin{DoxyCompactList}\small\item\em Start the worker threads. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aad45418d2b691dc4703b880e6d797b4d}} 
std\+::size\+\_\+t \textbf{ size} () const
\begin{DoxyCompactList}\small\item\em Get the thread pool size. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a0a5a9bec06e7984168530bdfb4cf0242}} 
std\+::size\+\_\+t \textbf{ n\+Waiting} () const
\begin{DoxyCompactList}\small\item\em Get the number of waiting threads. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a3be8a902065c31077ef345cd03036d01}} 
std\+::size\+\_\+t \textbf{ n\+Running} () const
\begin{DoxyCompactList}\small\item\em Get the number of threads currently handling a task. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a2ddd44c5ce7f7cd28e6acf9c0c4cbb0a}} 
std\+::size\+\_\+t \textbf{ free\+Slots} () const
\begin{DoxyCompactList}\small\item\em Get the number of free slots in the task queue. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a2ca960e716e99fd64eca3a107a43b4b1}} 
bool \textbf{ is\+Queue\+Empty} () const
\begin{DoxyCompactList}\small\item\em Whether the queue is empty. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a68cc65198d64d5f32ba889b1e0c1754b}} 
void \textbf{ clear\+Queue} ()
\begin{DoxyCompactList}\small\item\em Clear the queue. \end{DoxyCompactList}\item 
void \textbf{ set\+Max\+Queue\+Size} (std\+::size\+\_\+t max\+Queue\+Size)
\begin{DoxyCompactList}\small\item\em Set the maximum queue size. \end{DoxyCompactList}\item 
void \textbf{ set\+Accept\+Push} (bool accept)
\begin{DoxyCompactList}\small\item\em Set whether the thread pool accept data push. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a300c5d5df797a2a04d8c674c6dc3f348}} 
bool \textbf{ accept\+Push} () const
\begin{DoxyCompactList}\small\item\em Whether the thread pool accepts data push. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_ae5503a48ee34adcf03a7a4e53a7d75a0}} 
bool \textbf{ active} () const
\begin{DoxyCompactList}\small\item\em Whether the thread pool is active, meaning that the queue is not empty or at least one worker is active. \end{DoxyCompactList}\item 
void \textbf{ stop} (bool clear=true)
\begin{DoxyCompactList}\small\item\em Stop the thread pool. \end{DoxyCompactList}\item 
{\footnotesize template$<$class  = typename std\+::enable\+\_\+if$<$not std\+::is\+\_\+same$<$\+I\+N,void$>$\+::value$>$\+::type$>$ }\\Push\+Result \textbf{ push} (\textbf{ Push\+Policy} policy, IN \&\&input)
\begin{DoxyCompactList}\small\item\em Push a new task in the task queue. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a491b906d2052cbe1c394c75e0e2d72a5}} 
class {\bfseries Worker$<$ I\+N, O\+U\+T $>$}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename IN, typename O\+UT$>$\newline
class marlin\+::concurrency\+::\+Thread\+Pool$<$ I\+N, O\+U\+T $>$}

\doxyref{Thread\+Pool}{p.}{classmarlin_1_1concurrency_1_1ThreadPool} class The template parameter T is the type of data to enqueue and process in worker threads. 

\subsection{Member Enumeration Documentation}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aa812123afc377d93ad4d91cd6b3daed2}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!Push\+Policy@{Push\+Policy}}
\index{Push\+Policy@{Push\+Policy}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{Push\+Policy}
{\footnotesize\ttfamily template$<$typename IN, typename O\+UT$>$ \\
enum \textbf{ marlin\+::concurrency\+::\+Thread\+Pool\+::\+Push\+Policy}\hspace{0.3cm}{\ttfamily [strong]}}



Push\+Policy enumerator. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Blocking@{Blocking}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!Blocking@{Blocking}}}\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aa812123afc377d93ad4d91cd6b3daed2abd0ca6be53b0f3d2886fd53fcb52574e}} 
Blocking&Block until a slot is free in the queue. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Throw\+If\+Full@{Throw\+If\+Full}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!Throw\+If\+Full@{Throw\+If\+Full}}}\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aa812123afc377d93ad4d91cd6b3daed2afa9df3c61a331de501ef79fdfe81ad4a}} 
Throw\+If\+Full&Throw an exception if the queue is full. \\
\hline

\end{DoxyEnumFields}


\subsection{Member Function Documentation}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_aaf7bc6b1caed163cb2f54aa35c7246da}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!add\+Worker@{add\+Worker}}
\index{add\+Worker@{add\+Worker}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{add\+Worker()}
{\footnotesize\ttfamily template$<$typename IN , typename O\+UT $>$ \\
template$<$typename W\+O\+R\+K\+ER , typename ... Args$>$ \\
void \textbf{ marlin\+::concurrency\+::\+Thread\+Pool}$<$ IN, O\+UT $>$\+::add\+Worker (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add a new worker thread. 


\begin{DoxyParams}{Parameters}
{\em args} & arguments to pass to worker constructor \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_a60d1d6077b516d0aa5a2244c378e7979}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!push@{push}}
\index{push@{push}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{push()}
{\footnotesize\ttfamily template$<$typename IN, typename O\+UT $>$ \\
template$<$class $>$ \\
\textbf{ Thread\+Pool}$<$ IN, O\+UT $>$\+::Push\+Result \textbf{ marlin\+::concurrency\+::\+Thread\+Pool}$<$ IN, O\+UT $>$\+::push (\begin{DoxyParamCaption}\item[{\textbf{ Push\+Policy}}]{policy,  }\item[{IN \&\&}]{input }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Push a new task in the task queue. 

See Push\+Policy for runtime behavior of enqueuing.


\begin{DoxyParams}{Parameters}
{\em policy} & the push policy \\
\hline
{\em } & \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_af1b937d90dfd341103aa33eab98b136e}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!set\+Accept\+Push@{set\+Accept\+Push}}
\index{set\+Accept\+Push@{set\+Accept\+Push}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{set\+Accept\+Push()}
{\footnotesize\ttfamily template$<$typename IN , typename O\+UT $>$ \\
void \textbf{ marlin\+::concurrency\+::\+Thread\+Pool}$<$ IN, O\+UT $>$\+::set\+Accept\+Push (\begin{DoxyParamCaption}\item[{bool}]{accept }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set whether the thread pool accept data push. 


\begin{DoxyParams}{Parameters}
{\em accept} & whether to accept data push \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_ad665133f4e606e22dd13559601dfccbb}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!set\+Max\+Queue\+Size@{set\+Max\+Queue\+Size}}
\index{set\+Max\+Queue\+Size@{set\+Max\+Queue\+Size}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{set\+Max\+Queue\+Size()}
{\footnotesize\ttfamily template$<$typename IN , typename O\+UT $>$ \\
void \textbf{ marlin\+::concurrency\+::\+Thread\+Pool}$<$ IN, O\+UT $>$\+::set\+Max\+Queue\+Size (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{max\+Queue\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the maximum queue size. 


\begin{DoxyParams}{Parameters}
{\em max\+Queue\+Size} & the maximum queue size \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1concurrency_1_1ThreadPool_acbaed70df966cb82296cf7ba794e6705}} 
\index{marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}!stop@{stop}}
\index{stop@{stop}!marlin\+::concurrency\+::\+Thread\+Pool@{marlin\+::concurrency\+::\+Thread\+Pool}}
\subsubsection{stop()}
{\footnotesize\ttfamily template$<$typename IN , typename O\+UT $>$ \\
void \textbf{ marlin\+::concurrency\+::\+Thread\+Pool}$<$ IN, O\+UT $>$\+::stop (\begin{DoxyParamCaption}\item[{bool}]{clear = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Stop the thread pool. 

If the flag clear is set to true, the task queue is cleared. The threads are joined and the pool is clear. As no threads remains in the pool, the pool is not reusable. Thus this method must be called for performing a proper program termination before exiting


\begin{DoxyParams}{Parameters}
{\em clear} & whether the task queue should be cleared \\
\hline
\end{DoxyParams}


Referenced by marlin\+::concurrency\+::\+Thread\+Pool$<$ Input\+Type, Output\+Type $>$\+::$\sim$\+Thread\+Pool().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Thread\+Pool.\+h\end{DoxyCompactItemize}
