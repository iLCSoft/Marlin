\section{marlin\+:\+:Plugin\+Manager Class Reference}
\label{classmarlin_1_1PluginManager}\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}


\doxyref{Plugin\+Manager}{p.}{classmarlin_1_1PluginManager} singleton class Responsible for loading shared libraries and collecting processor factory instances.  




{\ttfamily \#include $<$Plugin\+Manager.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{classmarlin_1_1PluginManager_ad48570cd088c233a00f99a635bd4239c}} 
typedef std\+::shared\+\_\+ptr$<$ void $>$ {\bfseries Plugin\+Ptr}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a3ee0e73ead8c7cf123643f287dd01f64}} 
typedef std\+::function$<$ Plugin\+Ptr()$>$ {\bfseries Factory\+Function}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a71c1c15ffe8950ff59ecf433a1718f1d}} 
typedef std\+::map$<$ std\+::string, Factory\+Function $>$ {\bfseries Factory\+Map}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a23181783ed967345be21fc1ef646df61}} 
typedef std\+::map$<$ Plugin\+Type, Factory\+Map $>$ {\bfseries Plugin\+Factory\+Map}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a8e8e716c2e9cc49b8d5893f27cb51fc4}} 
typedef std\+::vector$<$ void $\ast$ $>$ {\bfseries Library\+List}
\item 
\mbox{\label{classmarlin_1_1PluginManager_aaa68e451e81c1c6a3ed93d0956468566}} 
typedef Logging\+::\+Logger {\bfseries Logger}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a6c9ccfc74852623f407135a60d9f3a4d}} 
typedef std\+::recursive\+\_\+mutex {\bfseries mutex\+\_\+type}
\item 
\mbox{\label{classmarlin_1_1PluginManager_af7e863ba57ed78b174279d53aff52f45}} 
typedef std\+::lock\+\_\+guard$<$ mutex\+\_\+type $>$ {\bfseries lock\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\void \textbf{ register\+Plugin} (Plugin\+Type type, const std\+::string \&name, bool ignore\+Duplicate=true)
\begin{DoxyCompactList}\small\item\em Register a new plugin to the manager. \end{DoxyCompactList}\item 
void \textbf{ register\+Plugin} (Plugin\+Type type, const std\+::string \&name, Factory\+Function factory\+Function, bool ignore\+Duplicate=true)
\begin{DoxyCompactList}\small\item\em Register a new plugin to the manager. \end{DoxyCompactList}\item 
bool \textbf{ load\+Libraries} (const std\+::string \&envvar=\char`\"{}M\+A\+R\+L\+I\+N\+\_\+\+D\+LL\char`\"{})
\begin{DoxyCompactList}\small\item\em Load shared libraries to populate the list of plugins. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \textbf{ plugin\+Names} (Plugin\+Type type) const
\begin{DoxyCompactList}\small\item\em Get all registered plugin name for the given type. \end{DoxyCompactList}\item 
bool \textbf{ plugin\+Registered} (Plugin\+Type type, const std\+::string \&name) const
\begin{DoxyCompactList}\small\item\em Whether the plugin of given type and name is registered. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::shared\+\_\+ptr$<$ T $>$ \textbf{ create} (Plugin\+Type type, const std\+::string \&name) const
\begin{DoxyCompactList}\small\item\em Create a new plugin instance. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1PluginManager_ac23d6fb4eff58932c797517efdfe4bbf}} 
void \textbf{ dump} () const
\begin{DoxyCompactList}\small\item\em Dump plugin manager content in console. \end{DoxyCompactList}\item 
\mbox{\label{classmarlin_1_1PluginManager_a9f7301e90cd1e63c4ed8feb95dfee642}} 
Logger \textbf{ logger} () const
\begin{DoxyCompactList}\small\item\em Get the plugin manager logger. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{classmarlin_1_1PluginManager_a70d1131b2f514ed29e8b69797c5abad4}} 
static \textbf{ Plugin\+Manager} \& \textbf{ instance} ()
\begin{DoxyCompactList}\small\item\em Get the plugin manager instance. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\doxyref{Plugin\+Manager}{p.}{classmarlin_1_1PluginManager} singleton class Responsible for loading shared libraries and collecting processor factory instances. 

\doxyref{Processor}{p.}{classmarlin_1_1Processor} instances can be created from factories using the \doxyref{Plugin\+Manager\+::create()}{p.}{classmarlin_1_1PluginManager_a637d123bd1f6bd8f4bc1ae6ee33d214c} method on query. 

\subsection{Member Function Documentation}
\mbox{\label{classmarlin_1_1PluginManager_a637d123bd1f6bd8f4bc1ae6ee33d214c}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!create@{create}}
\index{create@{create}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{create()}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::shared\+\_\+ptr$<$ T $>$ marlin\+::\+Plugin\+Manager\+::create (\begin{DoxyParamCaption}\item[{Plugin\+Type}]{type,  }\item[{const std\+::string \&}]{name }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Create a new plugin instance. 

A factory function must have been registered before hand. The template parameter T is the final plugin type requested by the caller.


\begin{DoxyParams}{Parameters}
{\em type} & the plugin type \\
\hline
{\em name} & the plugin name \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1PluginManager_ad74d076f457c0df28461dd89d932eee0}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!load\+Libraries@{load\+Libraries}}
\index{load\+Libraries@{load\+Libraries}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{load\+Libraries()}
{\footnotesize\ttfamily bool marlin\+::\+Plugin\+Manager\+::load\+Libraries (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{envvar = {\ttfamily \char`\"{}MARLIN\+\_\+DLL\char`\"{}} }\end{DoxyParamCaption})}



Load shared libraries to populate the list of plugins. 


\begin{DoxyParams}{Parameters}
{\em envvar} & the environment variable to load the libraries from \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1PluginManager_a845d591efb847a544bf9a0d2c81bc9f3}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!plugin\+Names@{plugin\+Names}}
\index{plugin\+Names@{plugin\+Names}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{plugin\+Names()}
{\footnotesize\ttfamily std\+::vector$<$ std\+::string $>$ marlin\+::\+Plugin\+Manager\+::plugin\+Names (\begin{DoxyParamCaption}\item[{Plugin\+Type}]{type }\end{DoxyParamCaption}) const}



Get all registered plugin name for the given type. 


\begin{DoxyParams}{Parameters}
{\em type} & the plugin type \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1PluginManager_a5fba86581eb9b75007f6fea095ea00a0}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!plugin\+Registered@{plugin\+Registered}}
\index{plugin\+Registered@{plugin\+Registered}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{plugin\+Registered()}
{\footnotesize\ttfamily bool marlin\+::\+Plugin\+Manager\+::plugin\+Registered (\begin{DoxyParamCaption}\item[{Plugin\+Type}]{type,  }\item[{const std\+::string \&}]{name }\end{DoxyParamCaption}) const}



Whether the plugin of given type and name is registered. 


\begin{DoxyParams}{Parameters}
{\em type} & the plugin type to check \\
\hline
{\em name} & the plugin name to check \\
\hline
\end{DoxyParams}
\mbox{\label{classmarlin_1_1PluginManager_a7727b55557b222b891e99a609acc66c7}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!register\+Plugin@{register\+Plugin}}
\index{register\+Plugin@{register\+Plugin}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{register\+Plugin()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void marlin\+::\+Plugin\+Manager\+::register\+Plugin (\begin{DoxyParamCaption}\item[{Plugin\+Type}]{type,  }\item[{const std\+::string \&}]{name,  }\item[{bool}]{ignore\+Duplicate = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Register a new plugin to the manager. 

A new factory function creating an object of type T is inserted into the registry. The type T must be default constructible. If you want to provide a custom factory function, use the corresponding overloaded function. If the flag ignore\+Duplicate is set to true, no exception is thrown in case a duplicate is found in the registry. In this case, the registry is not modified.


\begin{DoxyParams}{Parameters}
{\em type} & the plugin type \\
\hline
{\em name} & the plugin name \\
\hline
{\em ignore\+Duplicate} & whether to avoid exception throw in case of duplicate entry \\
\hline
\end{DoxyParams}


Referenced by marlin\+::\+Processor\+::\+Processor().

\mbox{\label{classmarlin_1_1PluginManager_a596aff81039e87c56109da3062f2bc51}} 
\index{marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}!register\+Plugin@{register\+Plugin}}
\index{register\+Plugin@{register\+Plugin}!marlin\+::\+Plugin\+Manager@{marlin\+::\+Plugin\+Manager}}
\subsubsection{register\+Plugin()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marlin\+::\+Plugin\+Manager\+::register\+Plugin (\begin{DoxyParamCaption}\item[{Plugin\+Type}]{type,  }\item[{const std\+::string \&}]{name,  }\item[{Factory\+Function}]{factory\+Function,  }\item[{bool}]{ignore\+Duplicate = {\ttfamily true} }\end{DoxyParamCaption})}



Register a new plugin to the manager. 

See overloaded function description for more details


\begin{DoxyParams}{Parameters}
{\em type} & the plugin type \\
\hline
{\em name} & the plugin name \\
\hline
{\em factory\+Function} & the factory function responsible for the plugin creation \\
\hline
{\em ignore\+Duplicate} & whether to avoid exception throw in case of duplicate entry \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Plugin\+Manager.\+h\item 
Plugin\+Manager.\+cc\end{DoxyCompactItemize}
